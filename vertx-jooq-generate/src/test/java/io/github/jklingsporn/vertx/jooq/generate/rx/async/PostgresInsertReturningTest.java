package io.github.jklingsporn.vertx.jooq.generate.rx.async;

import generated.classic.reactive.regular.vertx.tables.pojos.Something;
import generated.classic.reactive.regular.vertx.tables.pojos.Somethingcomposite;
import generated.classic.reactive.regular.vertx.tables.records.SomethingRecord;
import generated.classic.reactive.regular.vertx.tables.records.SomethingcompositeRecord;
import io.github.jklingsporn.vertx.jooq.generate.AbstractPostgresInsertReturningTest;
import io.github.jklingsporn.vertx.jooq.generate.Credentials;
import io.github.jklingsporn.vertx.jooq.rx.async.AsyncRXQueryExecutor;
import io.reactivex.Single;
import io.reactivex.SingleObserver;
import io.reactivex.disposables.Disposable;
import io.vertx.core.AsyncResult;
import io.vertx.core.Future;
import io.vertx.core.Handler;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import org.jooq.*;
import org.jooq.impl.DefaultConfiguration;
import org.junit.Assert;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.LocalDateTime;
import java.util.Random;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;

/**
 * @author jensklingsporn
 */
public class PostgresInsertReturningTest extends AbstractPostgresInsertReturningTest {

    private static final Logger logger = LoggerFactory.getLogger(PostgresInsertReturningTest.class);

    @Test
    public void insertReturningAutogeneratedIdShouldReturnId()  {
        Random random = new Random();
        SomethingRecord something = new SomethingRecord();
        something.setSomedouble(random.nextDouble());
        something.setSomeregularnumber(random.nextInt());
        something.setSomehugenumber(random.nextLong());
        something.setSomejsonarray(new JsonArray().add(1).add(2).add(3));
        something.setSomejsonobject(new JsonObject().put("key", "value"));
        something.setSomesmallnumber((short) random.nextInt(Short.MAX_VALUE));
        something.setSomestring("my_string");
        //someEnum has a default value and does not need to be set
        something.setSometimestamp(LocalDateTime.now());
        insertReturningShouldSucceed(generated.classic.reactive.regular.vertx.tables.Something.SOMETHING, something, Something::new, Integer.class);
    }

    @Test
    public void insertReturningWithIdShouldReturnId()  {
        Random random = new Random();
        SomethingRecord something = new SomethingRecord();
        something.setSomeid(random.nextInt());
        something.setSomedouble(random.nextDouble());
        something.setSomeregularnumber(random.nextInt());
        something.setSomehugenumber(random.nextLong());
        something.setSomejsonarray(new JsonArray().add(1).add(2).add(3));
        something.setSomejsonobject(new JsonObject().put("key", "value"));
        something.setSomesmallnumber((short) random.nextInt(Short.MAX_VALUE));
        something.setSomestring("my_string");
        //someEnum has a default value and does not need to be set
        something.setSometimestamp(LocalDateTime.now());
        insertReturningShouldSucceed(generated.classic.reactive.regular.vertx.tables.Something.SOMETHING, something, Something::new, Integer.class);
    }

    @Test
    public void insertReturningCompositeKeyShouldReturnId()  {
        Random random = new Random();
        insertReturningShouldSucceed(generated.classic.reactive.regular.vertx.tables.Somethingcomposite.SOMETHINGCOMPOSITE,new SomethingcompositeRecord().setSomejsonobject(new JsonObject()).setSomeid(random.nextInt()).setSomesecondid(random.nextInt()), Somethingcomposite::new, Record2.class);
    }

    @Test
    public void insertReturningCompositeKeyNotSetShouldFail()  {
        CountDownLatch latch = new CountDownLatch(1);
        runInsertReturning(generated.classic.reactive.regular.vertx.tables.Somethingcomposite.SOMETHINGCOMPOSITE, new SomethingcompositeRecord().setSomejsonobject(new JsonObject()), Somethingcomposite::new, latch, res->{
            Assert.assertTrue(res.failed());
            latch.countDown();
        });
    }

    private <R extends UpdatableRecord<R>,P,T> void insertReturningShouldSucceed(Table<R> table, R record, Function<JsonObject, P> pojoMapper, Class<T> clazz)  {
        try{
            CountDownLatch latch = new CountDownLatch(1);
            runInsertReturning(table, record, pojoMapper, latch, res -> {
                if (res.failed()) {
                    Assert.fail(res.cause().getMessage());
                } else {
                    Assert.assertTrue(clazz.isInstance(res.result()));
                }
                latch.countDown();
            });
        }catch(Throwable e){
            logger.error(e.getMessage(),e);
            Assert.fail(e.getMessage());
        }
    }

    private <R extends UpdatableRecord<R>,P,T> void runInsertReturning(Table<R> table, R record, Function<JsonObject, P> pojoMapper, CountDownLatch latch, Handler<AsyncResult<T>> resultHandler) {
        AsyncRXQueryExecutor<R,P,T> queryExecutor = new AsyncRXQueryExecutor<>(
                AsyncRXDatabaseClientProvider.getInstance().getClient(Credentials.POSTGRES),
                pojoMapper,
                table,
                false
        );
        Configuration configuration = new DefaultConfiguration();
        configuration.set(SQLDialect.POSTGRES);
        Single<T> insertReturning = queryExecutor.insertReturning(dslContext -> dslContext
                .insertInto(table)
                .set(record)
                .returning(table.getPrimaryKey().getFieldsArray())
                , keyMapper(table, configuration));
        insertReturning.subscribe(new SingleObserver<T>() {
            @Override
            public void onSubscribe(Disposable d) {

            }

            @Override
            public void onSuccess(T t) {
                resultHandler.handle(Future.succeededFuture(t));
            }

            @Override
            public void onError(Throwable x) {
                resultHandler.handle(Future.failedFuture(x));
            }
        });
        try {
            Assert.assertTrue(latch.await(1, TimeUnit.SECONDS));
        } catch (InterruptedException e) {
            Assert.fail(e.getMessage());
        }
    }

}
